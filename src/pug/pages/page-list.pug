extends ../layouts/_main.pug


block variables
    - const title = 'Студенческий портал - Список страниц';

block content
    style.
        .btn {
            width: 100%
        }

        .title--large {
            padding-left: 20px;
            padding-top: 20px
        }

        p {
            padding-left: 20px;
            font-size: 18px;
            padding-right: 20px;
            line-height: 26px;
        }

        pre, code {
            padding: 20px;
        }

        pre {
            background: #F1F4F9
        }

    .wrapper.container.container--aside.tabs__container(style="display: flex; margin-top: 40px")
        .tabs__buttons(style="width: 315px; gap: 10px")


            button.btn.btn--border.tabs__button.tabs__button--active(data-id="page-list") Список страниц
            button.btn.btn--border.tabs__button(data-id="introduction") Введение
            button.btn.btn--border.tabs__button(data-id="tech") Описание технологий
            button.btn.btn--border.tabs__button(data-id="arch") Архитектура проекта
            button.btn.btn--border.tabs__button(data-id="grid") Сетка
            button.btn.btn--border.tabs__button(data-id="buttons") Кнопки
            button.btn.btn--border.tabs__button(data-id="slider") Слайдер
            button.btn.btn--border.tabs__button(data-id="modals") Модальное окно
            button.btn.btn--border.tabs__button(data-id="datetime") Время / дата
            button.btn.btn--border.tabs__button(data-id="chart") Чарты / графики
            button.btn.btn--border.tabs__button(data-id="progress") Прогресс-бары
            button.btn.btn--border.tabs__button(data-id="tabs") Табы (вкладки)
            button.btn.btn--border.tabs__button(data-id="socials") Социальные иконки
            button.btn.btn--border.tabs__button(data-id="links") Ссылки
            button.btn.btn--border.tabs__button(data-id="cards") Карточки "товаров"
            button.btn.btn--border.tabs__button(data-id="range") Range-slider
            button.btn.btn--border.tabs__button(data-id="options") Option-select
            button.btn.btn--border.tabs__button(data-id="scrollbar") Scrollbar
            button.btn.btn--border.tabs__button(data-id="accordion") Accordion
            button.btn.btn--border.tabs__button(data-id="sidebar") SideBar

        .card--stack.tabs__item.tabs__item--active(style="margin-top: 0px" id="page-list")
            h1.title Список страниц
            ul.list(style="padding:0 20px;width: 100%;display: flex; flex-wrap: wrap; list-style: none;  justify-content: space-between;  align-items: center")
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="index.html" style="padding: 10px; display: block; text-align: center; width: 250px") index.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="dashboard.html" style="padding: 10px; display: block; text-align: center; width: 250px") dashboard.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="dashboard-vacancy.html"  style="padding: 10px; display: block; text-align: center; width: 250px") dashboard-vacancy.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="dashboard-request.html"  style="padding: 10px; display: block; text-align: center; width: 250px") dashboard-request.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="digital-portfolio.html"  style="padding: 10px; display: block; text-align: center; width: 250px") digital-portfolio.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="dashboard-payments.html"  style="padding: 10px; display: block; text-align: center; width: 250px") dashboard-payments.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="dashboard-question.html"  style="padding: 10px; display: block; text-align: center; width: 250px") dashboard-question.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="digital-profile.html"  style="padding: 10px; display: block; text-align: center; width: 250px") digital-profile.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="faq.html"  style="padding: 10px; display: block; text-align: center; width: 250px") faq.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="moderate.html"  style="padding: 10px; display: block; text-align: center; width: 250px") moderate.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="my-children-profile.html"  style="padding: 10px; display: block; text-align: center; width: 250px") my-children-profile.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="new-layout.html"  style="padding: 10px; display: block; text-align: center; width: 250px") new-layout.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="news.html" style="padding: 10px; display: block; text-align: center; width: 250px") news.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="parent.html" style="padding: 10px; display: block; text-align: center; width: 250px") parent.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="profile.html" style="padding: 10px; display: block; text-align: center; width: 250px") profile.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="profile-settings.html" style="padding: 10px; display: block; text-align: center; width: 250px") profile-settings.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="student-house.html" style="padding: 10px; display: block; text-align: center; width: 250px") student-house.html
                li.list__item(style=" border: 1px solid grey; margin-bottom: 10px;")
                    a.list__link(href="vacancy.html" style="padding: 10px; display: block; text-align: center; width: 250px") vacancy.html


        .card--stack.tabs__item(id="introduction")
            h1.title--large Введение
            p(style='padding-left: 20px') Привет, мир!
            p(style='padding-left: 20px') На этой странице я расскажу о различных нюансах при работе с проектом и, по возможности, отвечу на очевидные вопросы
            .accordeon-section
                p.accordeon-title.title--main Почему не Bootstrap (Foundation, smartGrid, другая_смешная_опция)?
                    button.accordeon-button
                .accordeon-container
                    h3 У CSS есть несколько базовых проблем, которые позволяют очень быстро отстрелить себе ногу при неправильном использовании:
                    ol
                        li
                            p Глобальный неймспейс – в серверном программировании все что написано в файле, в файле и остается. Все же что написано в css и js засирает глобальное пространство имен со всеми вытекающими. В JS эту проблему сейчас побороли всякими модульными системами, а вот с css сложнее. В идеальном мире это должен починить Shadow DOM и настоящие Web Components, но пока их нет единственный способ с этим бороться – следовать какой-то системе именований селекторов, которая по возможности уменьшает и исключает возможные конфликты.
                        li
                            p Каскадность – если на один элемент может сработать несколько правил, то они все и сработают последовательно. Если есть элемент h1.title, на него сработают все правила для тегов h1 и все правила для класса .title. Так как весь html состоит из тегов, то правил которые применяются на теги без классов будут работать на все вообще.
                            p Соответственно назначать или переназначать стили у тегов – это примерно то же самое, что править прототипы объектов в JS, чем в свое время печально славился <a href="http://prototypejs.org/" class="main__link">Prototype.js</a>. Эти стили унаследует вообще все объекты и если их потом захочется поменять, то результат будет такой же, как если ты решил в прототипе объекта поменять результаты какого-то метода, который используют все дети этого объекта. Вероятность что-то сломать почти 100%.
                        li
                            p Вложенные селекторы. Можно написать селекторы .nav .item {...} и .menu .item и .item в зависимости от места вывода будет показываться по-разному. Все хорошо пока тебе не нужно поместить блок menu внутрь блока nav. Тогда сайдэффекты становятся совершенно непредсказуемые. По сути аналог вложенных селекторов из программирования – это функция которая в зависимости от места где её вызывают, выдает разный результат. Например в одном месте sum(2,2) может возвращать 3, а в другом 5.

                    h3 Зачем нужны методологии
                    p Хорошая методология занимает предотвращением этих проблем. Покажу как это делает БЭМ, но CSS Modules, Polymer или всякие решения с инлайновыми стилями для Реакта тоже решают именно их, только другим способом.
                    p Как именование классов по БЭМу помогает решать эти проблемы:
                    ol
                        li
                            p БЭМ запрещает применять стили на теги, максимум ресет. На id тоже нельзя, потому что такие элементы нельзя на странице использовать 2 раза, а сколько раз он тебе понадобится ты не всегда знаешь заранее. Все стили можно применять только к классам.
                        li
                            p БЭМ создает для всех компонентов глобальный неймспейс – все классы которые относятся к компоненту начинаются с одного префикса. Это позволяет исправить второй пример таким образом: .nav__item, .menu__item. Если один вложить в другой не будет конфликта правил.
                        li
                            p Под каждый компонент в БЭМ создается своя папка – это защищает тебя от конфликтов в именах компонентов и при правильном использовании дает гарантию, что в глобальном неймспейсе будет только один компонент с таким префиксом.
                        li
                            p В БЭМ есть только один вид вложенных селекторов: модификатор > элемент. Оба начинаются с одного префикса, оба живут в одном файле, оба никак не влияют на другие компоненты.
                    h3 Что делает Bootstrap
                    p Bootstrap нарушает КАЖДОЕ из этих правил:
                    ol
                        li
                            p Bootstrap переназначает стили тэгов.
                        li
                            p Bootstrap в куче случаев меняет способ отображения элемента в зависимости от того, кто его родители. Хорошо хоть сейчас делает это через >, а не просто так. Но вот https://github.com/twbs/bootstrap/blob/master/scss/_button-groups.scss такие штуки все равно сильно уменьшают предсказуемость и усложняют редизайн.
                        li
                            p Bootstrap загрязняет глобальный неймспейс сотнями классов с очень generic именами: .table, .dropdown, .row, .left, и т. д. Которые надо все помнить и ни в коем случае не использовать самому.
                    p При таком подходе отстреливание себе ноги становится только вопросом времени.
            .accordeon-section
                p.accordeon-title.title--main Почему не jQuery(ExtJS, Mootools, другая_смешная_опция)?
                    button.accordeon-button
                .accordeon-container
                    p Раньше JavaScript использовали для небольших скриптов или несложных страниц, а теперь на нём делают вообще всё в интерфейсах сайтов.
                    p Библиотека jQuery была популярна из-за существования IE6 и большого количества браузеров с разной поддержкой веб-стандартов. Программист не мог быть уверен, что его код запустится у всех пользователей. Проще было взять jQuery и написать скрипты, которые будут работать одинаково вне зависимости от браузера.
                    p Также jQuery заметно облегчала работу с DOM, AJAX и анимациями.
                    h4 Когда jQuery уместна?
                    p Чтобы сделать простой сайт, который сами будете поддерживать (или не будете поддерживать вовсе — написали и забыли, так тоже бывает). Если сайт сложный, то чтобы работать над ним в большой команде, развивать и поддерживать, jQuery не подойдёт.
                    p На jQuery иногда пишут большие приложения, но их сложно и дорого поддерживать. В код нужно погружаться и всегда быть в контексте этой библиотеки, иначе уже через месяц будет сложно понять, что там написано.
                    p В полноценных фреймворках (например, Vue.js или Angular.js) возможности для нормальной работы уже идут «из коробки». Это, в первую очередь, компонентный подход к построению интерфейсов и абстрагирование от DOM. И любой человек, который придёт в команду со знанием фреймворка, сможет разобраться в коде — как минимум, потому что есть общепринятые структуры проектов, документация, сообщество и StackOverflow. Конечно, в jQuery тоже большое сообщество и тоже есть документация, но мне кажется, там каждый пишет код под себя.
                    h4 Но нужно ли?
                    p Это вопрос о выборе удобного инструмента для конкретной задачи. Простую страничку с простой формой можно написать и на jQuery. Но если всё, что вы пишете, это простые странички с формами, то это не значит, что нужно перестать изучать новое и знакомиться с современными фреймворками. Большинство вещей, в которых была полезна jQuery, уже добавлены в «ванильный» Javascript и без всяких библиотек.
                    p То есть обходные пути есть — главное их найти и разобраться.
            h3.title--large ES6!
            p Я стараюсь абстрогироваться от тонны библиотек, чтобы привести все к общему знаменателю, развиваться самим, развивать чистый язык, не увеличивать размер бандла => делать жизнь пользователя интерфейсом комфортной.
            h3.title--large Но если все-таки хочется?
            p Тогда используем методы ES6 и <a href="https://www.w3.org/TR/selectors-api/" class="main__link">Selectors API</a> или <a href="https://framework7.io/docs/dom7.html">Dom7 JS</a>
            pre
                code
                    | function $$(selector, node) {
                    |// NodeList имеет только метод item и свойство length. Array предоставляет гораздо более широкий набор функционал.
                    |return [].slice.call((node || document).querySelectorAll(selector));
                    |}
                    |// Та же функция на ES6 выглядит намного элегантнее
                    |const $$ = (selector, node = document) => [...node.querySelectorAll(selector)];
            h3.title--large А как же сторонние тысячи библиотек?
            p Все подключаемые библиотеки подключаются через npm и при сборке в бандл с помощью webpack убираются неиспользуемые компоненты, что значительно позволяет сократить бандл(хотя можно пожать еще больше, но я пока не гуру).
            p Пример moment.js (необходим для отрисовки chart.js), где убираются все локализации, кроме Русской
            pre
                code.
                    function js() {
                        return src(path.src.js)
                            .pipe(
                                webpackStream({
                                mode: "development",
                            output: {
                            filename: "script.js",
                            },
                            module: {
                            rules: [
                            {
                            test: /\.m?js$/,
                            exclude: /(node_modules|bower_components)/,
                                use: {
                                loader: "babel-loader",
                            options: {
                            presets: ["@babel/preset-env"],
                            },
                        },
                       },
                      ],
                     },
                           plugins: [
                            new webpack.ContextReplacementPlugin(
                            /moment[/\\]locale$/,
                            /ru/
                            ),
                           ],
                          })
                         )
                        .pipe(dest(path.build.js))
                        .pipe(uglify())
                        .pipe(
                              rename({
                              extname: ".min.js",
                            })
                           )
                        .pipe(dest(path.build.js))
                        .pipe(browsersync.stream());
                        }
        .card--stack.tabs__item(id="tech")
            h1.title Список технологий
            ol
                li.accordeon-section
                    p.accordeon-title.title--main БЭМ, как методология наименования классов
                        button.accordeon-button
                    .accordeon-container
                        .post__content
                            .intro
                                p
                                    a(href='https://ru.bem.info/') БЭМ
                                    |  расшифровывается как «Блок Элемент Модификатор». На самом деле, это целый стэк технологий, из которого мы воспользуемся только 
                                    a(href='https://ru.bem.info/methodology/naming-convention/') соглашением по именованию классов
                                    | .
                                p.title--xs Почему БЭМ?
                                ul
                                    li
                                        | БЭМ позволяет создавать абсолютно независимые блоки. Блоки и элементы получают уникальные имена, так что стили для одного элемента ничего не поломают в другом.
                                    li
                                        | БЭМ помогает легко придумывать любое количество классов, не повторяющихся между собой.
                                    li
                                        | БЭМ помогает писать самодокументирующийся код, в классе любого элемента содержится информация о нём.
                                p
                                    | Подробнее можно почитать в разделах  
                                    a(href='https://ru.bem.info/methodology/quick-start/') Быстрый старт 
                                    |  и 
                                    a(href='https://ru.bem.info/methodology/faq/') Часто задаваемые вопросы 
                                    |  на сайте 
                                    a(href='https://ru.bem.info/') bem.info

                                p.title--xs Что такое БЭМ ?
                                p БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste». БЭМ применяется по разному, кто-то использует только именования, кто-то берет за основу всю методологию себе на вооружение.
                                p Именование в БЭМ представляет собой определенный метод именования классов, этот метод позволяет:
                                ul
                                    li
                                        p Упростить код и его отладку
                                    li
                                        p Повторно использовать код избегая «Copy-Paste»
                                    li
                                        p Быстро понять связь между компонентами в разметке и CSS
                                    li
                                        p Ускорить написание css при использовании css-препроцессоров
                                p.title--xs Блок
                                p Блок — это самодостаточный независимый компонент страницы, который может быть повторно использован. Вся страница строится из блоков. Блоки могут содержать другие блоки. Классы блоков выглядят обычно и ничем не отличаются от любых других классов: header, navigate, works
                                pre.
                                    Блок Header
                                    header.header

                                    Блок Nav
                                    nav.nav
                                p.title--xs Элемент
                                p Cоставная часть блока, не может быть использована отдельно от блока. Например, пункт меню не может использоваться вне блока меню, он является его элементом. Класс элемента пишется так: block __ element
                                pre.
                                    Хорошо, элемент внутри родителя:

                                    Блок Header

                                    header.header
                                        img.header__logo

                                    Плохо, где элемент лежит вне своего родителя:

                                    header.header
                                    img.header__logo
                                p.title--xs Модификатор
                                p Модификатор определяет вид, состояние или поведение блока или элемента. Модификаторы не определяют основные стили блока или элемента, они лишь модифицируют (изменяют) его. Класс модификатора пишется так: block__element--modifier. В примере ниже мы изменили внешний вид активного и неактивного пункта меню с помощью модификаторов.
                                pre.
                                    Блок Nav
                                    nav.nav
                                        ul.nav__list
                                    Хорошо
                                            li class="nav__item nav__item--active
                                            li class="nav__item
                                    Плохо: модификатор применен без основного класса
                                            li.nav__item--active
                                p Таким образом стили:
                                pre.
                                    nav {
                                        font-size: 1rem
                                        }
                                    nav__item {
                                         font-size: 15px;
                                         color: #555;
                                            &--active{
                                                color: red;
                                                border-bottom: 1px solid;
                                            }
                                        }
                                    }
                                p Обратите внимание, что стили для блока и для элемента не определяются вложенностью, а вот модификатор блока или элемента может быть вложен. Так почему мы не вкладываем блок в элемент, если можем?
                                p Дело в том, что при вкладывании элемента в блок, мы можем подвергнуться напасти CSS - это каскад и блоки не будут модульными, а только усугубят положение, да и к тому же - усложнят чтение кода.
                li.accordeon-section
                    p.accordeon-title.title--main Модульный JavaScript, изоляция
                        button.accordeon-button
                    .accordeon-container
                        h3.title--xs Что такое модуль?
                        p Модуль – это просто файл. Один скрипт – это один модуль.
                        p Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:
                        ul
                            li
                                p <b>export</b> отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
                            li
                                p <b>import</b> позволяет импортировать функциональность из других модулей.
                        p Например, если у нас есть файл sayHi.js, который экспортирует функцию:
                        pre.
                            ../js/sayHi.js

                            export function sayHi(user) {
                              alert(`Hello, ${user}!`);
                            }
                        p …Тогда другой файл может импортировать её и использовать:
                        pre.
                            ../js/main.js

                            import {sayHi} from './sayHi.js';

                            alert(sayHi); // function...
                            sayHi('John'); // Hello, John!

                        p Модули или подобные структуры это неотъемлемая часть любого взрослого языка программирования. Просто иначе никак. Модули позволяют ограничить область видимости, позволяют реиспользовать части приложения, делают приложение более структурированным, отделяют ресурсы от шума и вообще делают код нагляднее.
                        p Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.
                        p В следующем примере импортированы 2 скрипта, и hello.js пытается использовать переменную user, объявленную в user.js. В итоге ошибка:

                          pre.
                                // hello.js
                                alert(user); // в этом модуле нет такой переменной (каждый модуль имеет независимые переменные)
                          pre.
                                // user.js
                                let user = "John";
                          pre.
                                // index.html
                                !doctype html
                                script(type="module" src="user.js")
                                script(type="module" src="hello.js")
                          pre.
                                // result

                li.accordeon-section
                    p.accordeon-title.title--main SCSS - Sassy CSS
                        button.accordeon-button
                    .accordeon-container
                        p.title--xs Зачем использовать Sass/SCSS вместо CSS?
                        ol
                            li
                                p Вложенность — SCSS позволяет вкладывать правила CSS друг в друга. Вложенные правила применяются только для элементов, соответствующих внешним селекторам (а если речь идёт о Sass, то там и без скобок всё красиво и интуитивно понятно).

                            li
                                p Переменные — в стандартном CSS тоже есть понятие переменных, но в Sass с ними можно работать немного по-другому. Например, повторять их через директиву @for. Или генерировать свойства динамически. Подробнее можете изучить на русскоязычном сайте проекта.

                            li
                                p Улучшенные математические операции— можно складывать, вычитать, умножать и делить значения CSS. В отличие от стандартного CSS, Sass/SCSS позволяют обойтись без calc().

                            li
                                p Тригонометрия — SCSS позволяет писать собственные (синусоидальные и косинусоидальные) функции, используя только синтаксис Sass/SCSS, подобно тому, как это можно делать в других языках вроде JavaScript.

                            li
                                p Директивы @for, @while и выражение @if-else — можно писать CSS-код, используя знакомые элементы из других языков. Но не обольщайтесь — в итоге на выходе будет обычный CSS.
                            li
                                p Миксины (примеси) — можно один раз создать набор CSS-свойств и работать с ними повторно или смешивать с другими значениями. Миксины можно использовать для создания отдельных тем одного макета. Примеси также могут содержать целые CSS-правила или что-либо другое, разрешённое в Sass-документе. Они даже могут принимать аргументы, что позволяет создавать большое разнообразие стилей при помощи небольшого количества миксинов.

                            li
                                p Функции — можно создавать определения CSS в виде функций для многократного использования.
                        p.title--xs Переменные?
                        p Да! Sass/SCSS позволяет работать с переменными. В CSS они обозначаются двойным тире (--), а в препроцессорах знаком доллара ($).
                        pre.
                            $number: 1;
                            $color: #ff0000;
                            $text: "tproger forever.";
                            $text: "IT forever." !default;
                            $nothing: null;
                        p Вы можете присваивать значение по умолчанию переменным, у которых ещё нет значения, добавив метку !default в конце значения. В таком случае, если переменной уже было присвоено значение, оно не изменится; если же переменная пуста, ей будет присвоено новое указанное значение.
                        pre.
                            #container {
                              content: $text;
                            }
                        p.title--xs Вложенные правила
                        p Стандартные вложенные CSS-элементы с использованием пробела:
                        pre.
                            /* Вложенные правила */
                            #A {
                              color: red;
                            }
                            #A #B {
                              color: green;
                            }
                            #A #B #C p {
                              color: blue;
                            }
                        p Те же вложенные элементы с помощью SCSS:
                        pre.
                            /* Вложенные правила */
                            #A {
                              color: red;
                              #B {
                                color: green;
                                #C p {
                                  color: blue;
                                }
                              }
                            }
                        p Амперсанд
                        p В SCSS используется директива &.
                        pre.
                            #p {
                              color: black;
                              a {
                                font-weight: bold;
                                &:hover {
                                  color: red;
                                }
                              }
                            }
                        p.title--xs Миксины (они же примеси)
                        p Миксины объявляются директивой @mixin. После неё должно стоять имя миксина и, опционально, его параметры, а также блок, содержащий тело миксина. Например, можно определить миксин flexible(), который далее будет включён, например, в класс .centered-elements следующим образом:
                        pre.
                            @mixin flexible () {
                                display: flex;
                                justify-content: center;
                                align-items: center;
                              }

                            .centered-elements {
                                @include flexible ();
                                border: 1px solid gray;
                              }
                        p Теперь каждый раз после применения класса .centered-elements к HTML-элементу, последний будет преобразован во Flexbox.


                li.accordeon-section
                    p.accordeon-title.title--main Gulp / Webpack
                        button.accordeon-button
                    .accordeon-container
                li.accordeon-section
                    p.accordeon-title.title--main .eslint / .stylelint / prettier / .editorconfig
                        button.accordeon-button
                    .accordeon-container
                li.accordeon-section
                    p.accordeon-title.title--main Модульный JavaScript, изоляция
                        button.accordeon-button
                    .accordeon-container
                li.accordeon-section
                    p.accordeon-title.title--main Препроцессор HTML pug / jade
                        button.accordeon-button
                    .accordeon-container
                li.accordeon-section
                    p.accordeon-title.title--main Графики / чарты Chart.js
                        button.accordeon-button
                    .accordeon-container
                li.accordeon-section
                    p.accordeon-title.title--main Слайдер SwiperJS
                        button.accordeon-button
                    .accordeon-container


        .card--stack.tabs__item(id="arch")
            h1.title Список страниц
        .card--stack.tabs__item(id="grid")
            h1.title Список страниц
        .card--stack.tabs__item(id="buttons")
            h1.title Список страниц
        .card--stack.tabs__item(id="slider")
            h1.title Список страниц
        .card--stack.tabs__item(id="modals")
            h1.title Список страниц
        .card--stack.tabs__item(id="datetime")
            h1.title Список страниц
        .card--stack.tabs__item(id="chart")
            h1.title Список страниц
        .card--stack.tabs__item(id="progress")
            h1.title Список страниц
        .card--stack.tabs__item(id="tabs")
            h1.title Список страниц
        .card--stack.tabs__item(id="socials")
            h1.title Список страниц
        .card--stack.tabs__item(id="links")
            h1.title Список страниц
        .card--stack.tabs__item(id="cards")
            h1.title Список страниц
        .card--stack.tabs__item(id="range")
            h1.title Список страниц
        .card--stack.tabs__item(id="options")
            h1.title Список страниц
        .card--stack.tabs__item(id="scrollbar")
            h1.title Список страниц
        .card--stack.tabs__item(id="accordion")
            h1.title Список страниц
        .card--stack.tabs__item(id="sidebar")
            h1.title Список страниц
